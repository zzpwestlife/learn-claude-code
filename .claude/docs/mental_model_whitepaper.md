# 心理模型应用白皮书：构建认知驱动的 AI 原生架构

## 1. 概述与目标

本文档旨在系统性地将 **奥卡姆剃刀 (Occam's Razor)** 与 **费曼技巧 (Feynman Technique)** 等核心心理模型，深度整合至现有的 AI 原生开发工作流中。

我们的目标不仅仅是引入理论，而是建立一套可执行的 **认知架构 (Cognitive Architecture)**，通过降低系统复杂度（奥卡姆剃刀）和提升信息传递的保真度（费曼技巧），强化我们现有的 **规范驱动开发 (SDD)** 和 **第一性原理**。

---

## 2. 现有第一性原理回顾 (The Foundation)

基于项目现有的 `constitution.md` 和架构文档，我们的基石如下：

1.  **规范驱动开发 (SDD):** 代码服务于规范，规范是唯一的真理之源。
2.  **简单性原则 (Simplicity First):** 遵循 YAGNI (You Aren't Gonna Need It)，拒绝过度设计。
3.  **明确性原则 (Clarity):** 显式优于隐式，代码必须对人类（及 AI）可读。
4.  **测试先行 (Test-First):** 红色-绿色-重构循环。

我们将以此为基础，引入新的心理模型进行升维。

---

## 3. 奥卡姆剃刀：复杂度熵减策略 (Occam's Razor)

> *"如无必要，勿增实体。" (Entities should not be multiplied beyond necessity.)*

在 AI 原生架构中，奥卡姆剃刀不仅是设计原则，更是对抗软件熵增的武器。

### 3.1 架构层面的剃刀 (Architectural Razor)
*   **Agent/Skill 最小化:** 在 `.claude/agents` 或 `.claude/skills` 中添加新能力前，必须通过 "存在性测试"。如果一个 Skill 可以通过优化 Prompt 或组合现有指令完成，则严禁创建新文件。
*   **依赖大清洗:** 在 `plan.md` 阶段，对每一个引入的外部库执行 "剃刀审查"。
    *   *提问:* "如果不引入这个库，我们能用标准库在 50 行代码内解决问题吗？"
    *   *行动:* 如果答案是肯定的，拒绝引入依赖。

### 3.2 代码层面的剃刀 (Code Razor)
*   **YAGNI 强化版:** 在 `spec.md` 编写阶段，任何标记为 "未来可能需要" 的功能点，直接剔除。AI 的生成成本很低，未来需要时再生成即可，无需现在预留接口。
*   **死代码零容忍:** 既然代码是 AI 生成的产物，我们不应产生"舍不得删"的情感。定期运行死代码检测，直接清理未被引用的函数和类型。

---

## 4. 费曼技巧：教学驱动开发 (Teaching-Driven Development)

> *"如果你不能简单地解释它，你就没有真正理解它。" (If you can't explain it simply, you don't understand it.)*

我们将费曼技巧转化为工程实践，称为 **教学驱动开发 (Teaching-Driven Development, TDDv2)**。

### 4.1 Spec 即教材 (Spec as Teaching Material)
*   **原则:** `spec.md` 不应是一份枯燥的需求列表，而应是一份写给 "大一新生"（即 AI Agent 上下文）的教学讲义。
*   **实践:** 如果 AI 无法根据 `spec.md` 生成正确的代码，**不要指责 AI，而是指责 Spec**。这意味着你的 "教学" 过于晦涩。
*   **行动:** 重写 Spec，使用更简单的类比、更清晰的因果关系描述，直到 AI 能一次性做对。

### 4.2 命名即解释 (Naming as Explanation)
*   **变量名:** 变量名必须包含完整的上下文意义，哪怕很长。
    *   *Bad:* `data`, `list`, `proc`
    *   *Good:* `usersPendingVerification`, `dailyTransactionReportList`, `processRefundRequest`
*   **注释策略:** 注释不解释 "代码做了什么" (What)，只解释 "为什么要这样做" (Why)。"What" 应该由代码本身（通过费曼技巧命名的变量）自解释。

### 4.3 橡皮鸭调试的 AI 化 (AI Rubber Ducking)
*   当遇到复杂 Bug 时，强制要求开发者在 Chat 中向 AI **完整地、从零开始地解释** 系统是如何工作的，以及预期是什么。
*   通常在解释的过程中（费曼技巧的应用），问题的根源就会浮现。

---

## 5. 理论整合矩阵 (Theoretical Integration Matrix)

我们将心理模型映射到 SDD 的具体阶段：

| SDD 阶段 | 核心任务 | 应用模型 | 具体行动 (Actionable Item) | 成功指标 (Metric) |
| :--- | :--- | :--- | :--- | :--- |
| **1. 意图定义** | 编写 `spec.md` | **费曼技巧** | 拒绝专业术语堆砌，用简单语言描述用户故事。 | AI 能复述出 100% 准确的意图。 |
| **2. 技术规划** | 编写 `plan.md` | **奥卡姆剃刀** | 审查每一个组件、数据库字段、API 接口的必要性。 | 方案中"可选"组件数量为 0。 |
| **2. 技术规划** | 选型 | **二阶思维** | 追问："引入这个技术栈 2 年后的维护成本是什么？" | 拒绝 2 个以上非必要的第三方依赖。 |
| **3. 任务分解** | 生成 `tasks.md` | **盖尔定律** | 确保第一个任务是构建一个最简的可运行系统 (MVP)。 | Task 1 完成后系统即可演示。 |
| **4. 自动化实现** | 生成代码 | **第一性原理** | 代码必须直接反映 Spec，不依赖隐含假设。 | 生成的代码无需人工修改逻辑。 |

---

## 6. 其他模型评估 (Evaluation of Other Models)

### 6.1 二阶思维 (Second-Order Thinking)
*   **定义:** 不仅考虑行动的直接后果，还要考虑后果的后果。
*   **项目应用:**
    *   **技术债务:** 快速生成的代码（一阶正向）可能导致难以维护的屎山（二阶负向）。
    *   **对策:** 在 `constitution.md` 中强制规定 **重构** 步骤。每次生成功能后，必须跟随一个 "Refactor" 任务，专门用于清理生成过程中产生的临时结构。

### 6.2 盖尔定律 (Gall's Law)
*   **定义:** 一个切实可行的复杂系统势必是从一个切实可行的简单系统发展而来的。
*   **项目应用:**
    *   **迭代策略:** 在 `spec.md` 中严禁 "大爆炸" 式的需求。必须定义 Version 0.1 (Skeleton)，确保骨架可用，再添加肌肉。

### 6.3 帕累托法则 (Pareto Principle / 80-20 Rule)
*   **定义:** 80% 的价值来自 20% 的功能。
*   **项目应用:**
    *   **MVP 聚焦:** 在 `spec.md` 评审中，强制询问："哪 20% 的功能构成了核心价值？" 优先实现这部分，其余功能放入 Backlog 或直接丢弃（奥卡姆剃刀）。

---

## 7. 结论

通过将 **奥卡姆剃刀**（做减法、去复杂）和 **费曼技巧**（做加法、增清晰）引入架构，我们构建了一个自我调节的系统：

*   **奥卡姆剃刀** 保护我们免受 AI 生成代码的无限膨胀和复杂度失控。
*   **费曼技巧** 确保我们传达给 AI 的意图是精准、无损的。

这两个模型互为阴阳，共同支撑起高效、可维护的 **AI 原生开发工作流**。
