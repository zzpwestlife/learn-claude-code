# 技术调研与发现

## 需求分析

### 核心任务
实现一个教学级斐波那契数列函数，强调代码可读性和最佳实践演示。

### 技术要求
- **语言**: Python 3.x
- **实现方式**: 迭代法（避免递归栈溢出和性能问题）
- **复杂度**: O(n) 时间，O(1) 空间
- **测试框架**: unittest（Python 标准库）
- **代码风格**: PEP 8 + 类型注解 + 中文文档字符串

## 实现要点

### 1. 算法设计
**斐波那契数列定义**:
- F(0) = 0
- F(1) = 1
- F(n) = F(n-1) + F(n-2) (n ≥ 2)

**迭代法优势**:
- 避免递归的 O(n) 栈空间消耗
- 避免重复计算（递归法是 O(2^n)）
- 代码逻辑清晰，适合教学

**实现思路**:
```python
# 边界处理
if n == 0: return 0
if n == 1: return 1

# 迭代计算（仅需两个变量）
prev, curr = 0, 1
for _ in range(2, n + 1):
    prev, curr = curr, prev + curr
return curr
```

### 2. 输入验证策略

**防御性编程层次**:
1. **类型检查**: 使用 `isinstance(n, int)` 拒绝 float、str 等
2. **范围检查**: 验证 `n >= 0`，拒绝负数
3. **异常类型**:
   - `TypeError`: 非整数类型（如 "5", 3.14）
   - `ValueError`: 负整数（如 -1）

**验证顺序**: 先类型后范围（避免对非数值类型进行比较）

### 3. 测试覆盖矩阵

| 测试类别 | 测试用例 | 预期结果 |
|---------|---------|---------|
| **基础功能** | fibonacci(0) | 0 |
|  | fibonacci(1) | 1 |
|  | fibonacci(5) | 5 |
|  | fibonacci(10) | 55 |
| **边界情况** | fibonacci(0) | 0（最小有效值） |
|  | fibonacci(50) | 12586269025（性能测试） |
| **错误处理** | fibonacci(-1) | ValueError |
|  | fibonacci(3.5) | TypeError |
|  | fibonacci("10") | TypeError |
| **递推验证** | F(n) = F(n-1) + F(n-2) | 对所有 n ≥ 2 成立 |

### 4. 教学友好设计

**代码可读性增强**:
- 使用清晰的变量名（`prev`, `curr` 而非 `a`, `b`）
- 添加详细的行内中文注释
- 完整的 docstring（包含参数、返回值、异常、示例）

**最佳实践演示**:
- 类型注解（Type Hints）
- EAFP vs LBYL 风格（此处使用 LBYL：先验证再处理）
- 清晰的异常消息

## 潜在挑战与解决方案

### 挑战 1: 大数性能
**问题**: n=50 时结果已达到 12,586,269,025，超出 32 位整数范围
**解决**: Python 自动处理大整数，无需特殊处理

### 挑战 2: 类型检查边界情况
**问题**: `isinstance(True, int)` 返回 True（bool 是 int 的子类）
**解决**: 需要额外检查 `type(n) is int` 或 `isinstance(n, bool)` 排除布尔值

### 挑战 3: 测试可读性
**问题**: 多个相似的测试用例可能导致代码重复
**解决**: 使用 `unittest.TestCase` 的清晰命名，每个测试专注单一场景

## 依赖项
- Python 3.6+ (支持类型注解)
- 无需第三方库（使用标准库 unittest）

## 验证标准
- [ ] 所有测试用例通过（`python -m unittest test_fibonacci.py`）
- [ ] 代码符合 PEP 8（可用 `pylint` 或 `flake8` 验证）
- [ ] 100% 测试覆盖率（包括正常和异常路径）
- [ ] 中文注释和文档字符串完整
